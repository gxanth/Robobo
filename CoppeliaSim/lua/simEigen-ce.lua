local codeEditorInfos=[[
string handle = simEigen.mtxBlock(string handle, int i=0, int j=0, int p=-1, int q=-1)
simEigen.mtxBlockAssign(string handle, string handle2, int i=0, int j=0, int p=-1, int q=-1)
string handle = simEigen.mtxCopy(string handle)
string handle = simEigen.mtxCross(string handle, string handle2)
simEigen.mtxDestroy(string handle)
float result = simEigen.mtxDeterminant(string handle)
float result = simEigen.mtxDot(string handle, string handle2)
float[] data = simEigen.mtxGetColData(string handle, int j)
float[] data = simEigen.mtxGetData(string handle)
float data = simEigen.mtxGetItem(string handle, int i, int j)
float[] data = simEigen.mtxGetRowData(string handle, int i)
int rows, int cols = simEigen.mtxGetSize(string handle)
string handle = simEigen.mtxHorzCat(string[] handles)
simEigen.mtxIMul(string handle, string handle2)
string handle = simEigen.mtxKron(string handle, string handle2)
string handle = simEigen.mtxLinSpaced(int count, float low=1, float high=nil)
float result = simEigen.mtxMaxCoeff(string handle)
float result = simEigen.mtxMean(string handle)
float result = simEigen.mtxMinCoeff(string handle)
string handle = simEigen.mtxMul(string handle, string handle2)
string handle = simEigen.mtxNew(int rows, int cols, float[] initialData={})
float result = simEigen.mtxNorm(string handle)
simEigen.mtxNormalize(string handle)
string handle = simEigen.mtxNormalized(string handle)
string handle = simEigen.mtxOp(string handle, int op, string handle2=nil, bool inplace=true)
string handle = simEigen.mtxOpK(string handle, int op, float k, bool inplace=true)
string m, string x = simEigen.mtxPInv(string m, string b=nil, float damping=0)
float result = simEigen.mtxProd(string handle)
string handle = simEigen.mtxReshaped(string handle, int rows, int cols)
simEigen.mtxSetColData(string handle, int j, float[] data)
simEigen.mtxSetData(string handle, float[] data)
simEigen.mtxSetItem(string handle, int i, int j, float data)
simEigen.mtxSetRowData(string handle, int i, float[] data)
float result = simEigen.mtxSquaredNorm(string handle)
float result = simEigen.mtxSum(string handle)
string s, string u, string v, string x = simEigen.mtxSVD(string m, bool computeThinU=true, bool computeThinV=true, string b=nil)
float result = simEigen.mtxTrace(string handle)
simEigen.mtxTranspose(string handle)
string handle = simEigen.mtxTransposed(string handle)
string handle = simEigen.mtxVertCat(string[] handles)
simEigen.quatDestroy(string handle)
string handle = simEigen.quatFromAxisAngle(string axisHandle, float angle)
string handle = simEigen.quatFromEuler(string handle)
string handle = simEigen.quatFromRotation(string handle)
float[4] data = simEigen.quatGetData(string handle)
string handle = simEigen.quatInv(string handle)
string handle = simEigen.quatMulQuat(string handle, string handle2, bool inplace=true)
string handle = simEigen.quatMulVec(string handle, string vectorHandle)
string handle = simEigen.quatNew(float[4] initialData={0,0,0,1})
simEigen.quatSetData(string handle, float[4] data)
string handle = simEigen.quatSLERP(string handle, string handle2, float t)
string axisHandle, float angle = simEigen.quatToAxisAngle(string handle)
string handle = simEigen.quatToEuler(string handle)
string handle = simEigen.quatToRotation(string handle)
grid s, grid u, grid v, grid x = simEigen.svd(grid m, bool computeThinU=true, bool computeThinV=true, grid b=nil)
grid m, grid x = simEigen.pinv(grid m, grid b=nil, float damping=0)
map m = simEigen.Matrix:abs()
map m = simEigen.Matrix:acos()
map m = simEigen.Matrix:add(map m2)
map m = simEigen.Matrix:asin()
map m = simEigen.Matrix:atan()
map m = simEigen.Matrix:block(int i, int j, int p, int q)
map self = simEigen.Matrix:blockassign(map m, int i, int j, int p, int q)
map m = simEigen.Matrix:ceil()
map m = simEigen.Matrix:col(int j)
float[] a = simEigen.Matrix:coldata(int j)
int number = simEigen.Matrix:cols()
map m = simEigen.Matrix:copy()
map m = simEigen.Matrix:cos()
int number = simEigen.Matrix:count()
map v = simEigen.Matrix:cross(map v2)
float[] a = simEigen.Matrix:data()
map m = simEigen.Matrix:deg()
float d = simEigen.Matrix:det()
map m = simEigen.Matrix:div(map m2)
float the = simEigen.Matrix:dot(map v2)
map m = simEigen.Matrix:exp()
map m = simEigen.Matrix:eye(int n)
map m = simEigen.Matrix:floor()
map m = simEigen.Matrix:horzcat(map m2)
map self = simEigen.Matrix:iabs()
map self = simEigen.Matrix:iacos()
map self = simEigen.Matrix:iadd(map m)
map self = simEigen.Matrix:iasin()
map self = simEigen.Matrix:iatan()
map self = simEigen.Matrix:iceil()
map self = simEigen.Matrix:icos()
map self = simEigen.Matrix:ideg()
map self = simEigen.Matrix:idiv(map m)
map self = simEigen.Matrix:iexp()
map self = simEigen.Matrix:ifloor()
map self = simEigen.Matrix:iintdiv(map m)
map self = simEigen.Matrix:ilog()
map self = simEigen.Matrix:ilog2()
map self = simEigen.Matrix:ilog10()
map self = simEigen.Matrix:imax(map m)
map self = simEigen.Matrix:imin(map m)
map self = simEigen.Matrix:imod(map m)
map self = simEigen.Matrix:imul(map m)
map m = simEigen.Matrix:intdiv(map m2)
map m = simEigen.Matrix:inversetransform()
map self = simEigen.Matrix:irad()
map self = simEigen.Matrix:isin()
bool true = simEigen.Matrix:ismatrix(any m)
bool true = simEigen.Matrix:isorthogonal(float tol=1e-6)
map self = simEigen.Matrix:isqrt()
map self = simEigen.Matrix:isub(map m)
bool true = simEigen.Matrix:isvector(any m)
map self = simEigen.Matrix:itan()
map self = simEigen.Matrix:itimes(map m)
float value = simEigen.Matrix:item(int i, int j)
map m = simEigen.Matrix:kron(map m2)
map m = simEigen.Matrix:linspace(float low, float high, int count)
map m = simEigen.Matrix:log()
map m = simEigen.Matrix:log2()
map m = simEigen.Matrix:log10()
map m = simEigen.Matrix:max(map m2)
float result = simEigen.Matrix:maxcoeff()
float result = simEigen.Matrix:maxcoeff()
map m = simEigen.Matrix:min(map m2)
float result = simEigen.Matrix:maxcoeff()
map m = simEigen.Matrix:mod(map m2)
map m = simEigen.Matrix:mul()
float result = simEigen.Matrix:norm()
map self = simEigen.Matrix:normalize()
map m = simEigen.Matrix:normalized()
map m, map the = simEigen.Matrix:pinv(map b, float damping)
simEigen.Matrix:print()
float damping = simEigen.Matrix:prod()
map m = simEigen.Matrix:rad()
map m = simEigen.Matrix:reshaped(int rows, int cols)
map m = simEigen.Matrix:row(int i)
float[] a = simEigen.Matrix:rowdata(int i)
int number = simEigen.Matrix:rows()
map self = simEigen.Matrix:setcol(int j, map col)
map self = simEigen.Matrix:setcoldata(int j, float[] data)
map self = simEigen.Matrix:setdata(float[] data)
map self = simEigen.Matrix:setitem(int i, int j, float[] data)
map m = simEigen.Matrix:setrow(int i, map row)
map self = simEigen.Matrix:setrowdata(int i, float[] data)
map m = simEigen.Matrix:sin()
map m = simEigen.Matrix:sqrt()
float result = simEigen.Matrix:norm()
map m = simEigen.Matrix:sub(map m2)
float damping = simEigen.Matrix:prod()
map s, map u, map v, map x = simEigen.Matrix:svd(bool computeThinU=false, bool computeThinV=false, map b=nil)
map m = simEigen.Matrix:tan()
map m = simEigen.Matrix:times(map m2)
float trace = simEigen.Matrix:trace()
map m = simEigen.Matrix:transform(map v)
map self = simEigen.Matrix:transpose()
map m = simEigen.Matrix:transposed()
map m = simEigen.Matrix:vertcat(map m2)
map m = simEigen.Matrix(int rows, int cols, float[] data)
map v = simEigen.Vector(int size, float[] data)
float[] data = simEigen.Quaternion:data()
map q = simEigen.Quaternion:fromaxisangle(map axis, float angle)
map q = simEigen.Quaternion:fromeuler(map euler)
map q = simEigen.Quaternion:fromrotation(map r)
map self = simEigen.Quaternion:imul(map o)
map result = simEigen.Quaternion:inv()
bool true = simEigen.Quaternion:isquaternion(any m)
map q = simEigen.Quaternion:mul(map o)
map q = simEigen.Quaternion:slerp(float t, map q2)
map axis, float angle = simEigen.Quaternion:toaxisangle()
map euler = simEigen.Quaternion:toeuler()
map q = simEigen.Quaternion:torotation()
map q = simEigen.Quaternion(float[] data={})
float[] data = simEigen.Pose:data()
map p = simEigen.Pose:fromtransform(map m)
map result = simEigen.Pose:inv()
bool true = simEigen.Pose:ispose(any m)
map p = simEigen.Pose:mul(map o)
map m = simEigen.Pose:totransform()
map p = simEigen.Pose(map t, map q)
simEigen.op.unm
simEigen.op.abs
simEigen.op.acos
simEigen.op.asin
simEigen.op.atan
simEigen.op.ceil
simEigen.op.cos
simEigen.op.deg
simEigen.op.exp
simEigen.op.floor
simEigen.op.log
simEigen.op.log2
simEigen.op.log10
simEigen.op.rad
simEigen.op.sin
simEigen.op.sqrt
simEigen.op.tan
simEigen.op.add
simEigen.op.sub
simEigen.op.times
simEigen.op.div
simEigen.op.intdiv
simEigen.op.mod
simEigen.op.min
simEigen.op.max
]]

registerCodeEditorInfos("simEigen",codeEditorInfos)
